/*
 * Dynamic-allocation wrapper for the NUMA-aware HMCS lock.
 *
 * Paper reference: Section 4.1 - HMCS is one of the NUMA-aware hierarchical
 *                  locks evaluated in Figures 7 and 14.
 *                  See Chabbi et al., "High performance locks for multi-level
 *                  NUMA systems", PPoPP '15.
 *
 * The underlying numa_hmcslock (generated by lib/lockgen/hmcs.py into
 * numa_hmcslock.h) uses a statically-sized lock structure. This wrapper adds
 * dynamic allocation (malloc/free) so that Tilt's per-lock bookkeeping can
 * manage HMCS locks that are created and destroyed at runtime, matching the
 * lifecycle of pthread_mutex_init / pthread_mutex_destroy calls intercepted
 * via LD_PRELOAD.
 *
 * The "d" prefix in "dnuma_hmcslock" stands for "dynamic".
 *
 * This file is NOT auto-generated; it is a hand-written adapter that lives
 * alongside the generated numa_hmcslock.h header.
 */

#include "numa_hmcslock.h"

typedef struct dnuma_hmcs_node_s {
    numa_hmcs_node_t node;
} dnuma_hmcs_node_t;

typedef struct dnuma_hmcslock_s {
    numa_hmcslock_t *lock;
} dnuma_hmcslock_t;

static void
dnuma_hmcslock_init(dnuma_hmcslock_t* lock)
{
    lock->lock = malloc(sizeof(numa_hmcslock_t));
    numa_hmcslock_init(lock->lock);
}

static void
dnuma_hmcslock_destroy(dnuma_hmcslock_t* lock)
{
    free(lock->lock);
    lock->lock = NULL;
}

static void
dnuma_hmcslock_acquire(dnuma_hmcslock_t* lock, dnuma_hmcs_node_t *node)
{
    numa_hmcslock_acquire(lock->lock, &(node->node));
}

static void
dnuma_hmcslock_release(dnuma_hmcslock_t* lock, dnuma_hmcs_node_t *node)
{
    numa_hmcslock_release(lock->lock, &(node->node));
}
